digraph tree {
module -> contains
module -> rotate
contains -> and
contains -> indicates
and -> ::
and -> binary
:: -> (w)
:: -> =>
(w) -> (node)
(w) -> -
(node) -> (
(node) -> (red_uncle)
( -> &
( -> (new%word
& -> "then"
& -> '')
(new%word -> (associated
(red_uncle) -> (red)
(red_uncle) -> (v)
- -> )
- -> 0)
) -> (x%parent)
) -> +
(x%parent) -> (x
(x%parent) -> (x's
0) -> --
0) -> 2
2 -> 1
2 -> 3
3 -> :)
=> -> <pivot>
=> -> all
<pivot> -> <
<pivot> -> =
= -> ==
all -> a
all -> also
a -> >
a -> add
add -> about
add -> address
also -> allocate(current)
also -> an
allocate(current) -> allocatable
allocate(current) -> along
an -> always
binary -> associated(w)
binary -> child
associated(w) -> as
associated(w) -> at
as -> are
as -> associated
associated -> ascending
at -> associated(x%parent%parent)
at -> be
associated(x%parent%parent) -> associated(x
associated(x%parent%parent) -> associated(x%parent)
associated(x%parent) -> associated(y)
be -> back
be -> becomes
becomes -> been
child -> can't
child -> compare(new%word
can't -> by
can't -> causes
by -> branch
by -> call
branch -> black
call -> calls
causes -> case
causes -> change
change -> character(len=
compare(new%word -> colored
compare(new%word -> containing
colored -> code
colored -> comes
indicates -> functions
indicates -> is
functions -> do
functions -> if(associated(x
do -> current
do -> exit
current -> create_node
current -> determined
create_node -> count
create_node -> creates
count -> create
creates -> create_node()
determined -> current%word
determined -> directly
current%word -> current%color
current%word -> data
exit -> else
exit -> for
else -> dummy_current
else -> eqv
eqv -> end
eqv -> exexuted
end -> encountered
end -> ensure
for -> find
for -> from
find -> field
find -> following
field -> file
from -> found
if(associated(x -> if
if(associated(x -> if(res
if -> graft
if -> if(associated
graft -> given
graft -> has
given -> get
given -> global
has -> grandparent
has -> have
if(associated -> if(
if(associated -> if(associated(current%left)
if(associated(current%left) -> if(associated(current%right)
if(res -> if(associated(y%left)
if(res -> implicit
if(associated(y%left) -> if(associated(x%parent
if(associated(y%left) -> if(iterating)
if(iterating) -> if(associated(y%right)
if(iterating) -> if(new_word
implicit -> image
implicit -> in
in -> incoming:
is -> insert_in_tree
is -> left
insert_in_tree -> initialized
insert_in_tree -> inserted
initialized -> initial
initialized -> insert
inserted -> insert_in_tree(new)
inserted -> integer
insert_in_tree(new) -> insert_in_tree(current)
integer -> insertion
integer -> into
into -> interchanged
left -> it's
left -> make
it's -> isolated
it's -> iterating)
isolated -> it
iterating) -> iterating
iterating) -> its
make -> logical
make -> mirror
logical -> loop
rotate -> parent
rotate -> value
parent -> none
parent -> procedure
none -> node
none -> nullify
node -> new
node -> node_def
new -> must
new -> new_word
must -> move
new_word -> new%parent
new_word -> next
node_def -> node's
node_def -> nodes
nodes -> non-existent
nullify -> now
nullify -> on
now -> not
now -> null
on -> nullify(current%right)
on -> only
nullify(current%right) -> nullify(current%left)
nullify(current%right) -> of
only -> one
only -> or
or -> order
procedure -> place
procedure -> record
place -> performs
place -> pointer
performs -> path
performs -> pivot
path -> part
pointer -> point
pointer -> points
point -> places
points -> pointers
points -> position
position -> prints
record -> re-colors
record -> res
re-colors -> public
re-colors -> rebalance_tree
public -> progresses
public -> put
rebalance_tree -> ready
rebalance_tree -> rebalances
rebalances -> rebalance_tree(dummy_current)
rebalances -> receives
res -> red-black
res -> right
red-black -> recursive
red-black -> red_uncle
recursive -> record(current)
recursive -> red
right -> retrieves
right -> root%color
retrieves -> retrieve
retrieves -> return
root%color -> root
root%color -> root)
value -> to
value -> x
to -> same
to -> use
same -> rotate_right
same -> subroutines
rotate_right -> rotate_left(pivot)
rotate_right -> rotated
rotate_left(pivot) -> rotate_left
rotate_left(pivot) -> rotate_left(x)
rotate_left(x) -> rotate_left(x%parent%parent)
rotated -> rotate_right(x%parent%parent)
rotated -> rotation
rotate_right(x%parent%parent) -> rotate_right(pivot)
rotate_right(x%parent%parent) -> rotate_right(x)
subroutines -> segment
subroutines -> the
segment -> searched
segment -> sub-node
searched -> search
searched -> seen_eof
sub-node -> sub-
sub-node -> subroutine
the -> terminates
the -> there's
terminates -> take
terminates -> that
take -> subtree
take -> temporary
there's -> then
there's -> this
then -> there
use -> tree:
use -> v%left
tree: -> traverse
tree: -> type
traverse -> travel
traverse -> traverse(current)
travel -> to_lower(read_one())
travel -> traversal
traverse(current) -> traverse(current%left)
traverse(current) -> tree
traverse(current%left) -> traverse(current%right)
type -> tree_collection
type -> until
tree_collection -> true
until -> uncle
until -> up
v%left -> v
v%left -> v%word)
v -> v%iword
v%word) -> v%right
x -> which
x -> x%parent%right
which -> w%word)
which -> word
w%word) -> w%left
w%word) -> we
w%left -> w
w%left -> w%right
w -> values
word -> whose
word -> word_collection
whose -> with
word_collection -> words
x%parent%right -> x%parent%parent
x%parent%right -> y
x%parent%parent -> x%parent%left
x%parent%parent -> x%parent%parent%left)
x%parent%left -> x%parent
x%parent%left -> x%parent%left)
x%parent -> x%left
x%parent -> x%parent%color
x%parent%parent%left) -> x%parent%parent%color
x%parent%parent%left) -> x%parent%parent%right
x%parent%parent%color -> x%parent%parent%left
y -> x%right
y -> y%left%parent
x%right -> x%parent%right))
x%right -> x's
x%parent%right)) -> x%parent%right)
x's -> x)
y%left%parent -> y%left
y%left%parent -> y%right
y%left -> y%color
y%right -> y%parent
y%right -> y's
y's -> y%right%parent
}
